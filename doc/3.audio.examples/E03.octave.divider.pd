#N canvas 434 23 771 690 12;
#X declare -stdpath ./;
#X obj 395 225 loadbang;
#X obj 53 408 hip~ 5;
#X obj 511 101 adc~ 1;
#X obj 395 280 soundfiler;
#X obj 54 466 output~;
#X obj 511 161 tabwrite~ E03-table;
#X obj 180 243 osc~;
#X obj 133 154 moses 1;
#X obj 113 224 *~;
#X obj 180 192 mtof;
#X obj 180 220 *;
#X msg 229 168 0.5;
#X floatatom 229 197 4 0 0 0 - - - 0;
#X msg 267 168 15;
#X obj 114 247 *~ 2;
#X obj 229 143 loadbang;
#N canvas 414 195 519 300 looper 0;
#N canvas 0 0 450 300 (subpatch) 0;
#X array E03-table 62079 float 0;
#X coords 0 1.02 62078 -1.02 200 130 1 0 0;
#X restore 257 54 graph;
#X obj 66 170 outlet~;
#X obj 66 126 tabplay~ E03-table;
#X obj 66 100 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc #000000
#000000;
#X obj 66 69 loadbang;
#X text 265 193 ---- 62079 samples ----;
#X text 148 231 You can replace this with an [adc~] if you want to
go live., f 31;
#X connect 2 0 1 0;
#X connect 2 1 3 0;
#X connect 3 0 2 0;
#X connect 4 0 3 0;
#X restore 133 61 pd looper;
#X text 479 231 re-read original sample;
#X obj 523 133 bng 17 250 50 0 empty empty empty 0 -6 0 8 #dfdfdf #000000
#000000;
#N canvas 300 203 576 337 delay 0;
#X obj 43 250 outlet~;
#X obj 42 38 inlet~;
#X obj 43 119 loadbang;
#X obj 42 66 delwrite~ E03-del 40;
#X obj 43 223 delread~ E03-del;
#X obj 43 180 expr 1000*1024/$f1;
#X obj 43 145 samplerate~;
#X text 194 59 write to delay line which has enough memory to hold
40 msec, f 30;
#X text 153 145 get sample rate at load time;
#X text 186 174 divide 1024 by sample rate to give time in seconds
\; multiply by 1000 to convert to milliseconds.;
#X text 196 225 read from the delay line at the calculated delay;
#X text 272 274 1024-sample delay;
#X connect 1 0 3 0;
#X connect 2 0 6 0;
#X connect 4 0 0 0;
#X connect 5 0 4 0;
#X connect 6 0 5 0;
#X restore 47 136 pd delay;
#X text 89 16 OCTAVE DIVIDING VIA RING MODULATION;
#X obj 51 61 adc~ 1;
#X text 300 168 <= choose an effect;
#X obj 502 25 declare -stdpath ./;
#X text 542 132 <-- record a sample;
#X msg 395 252 read -resize ../sound/voice.wav E03-table;
#X obj 133 109 sigmund~ -npts 2048 -hop 2014 -maxfreq 1000 pitch;
#X text 174 333 This patch demonstrates using ring modulation to alias
a sound down one octave. The ring modulation itself ([osc~] and multiplier)
is easy. (We step it up by a factor of 2 to balance the original better.)
, f 74;
#X text 175 385 Harder is getting the fundamental frequency of the
original sound. We do this with the complicated [sigmund~] object \,
which puts out a stream of analysis data for an incoming signal. The
"-npts 2048" argument specifies the analysis window size. The analysis
is most closely aligned with what the sound was doing at the middle
of the window \, i.e. \, 1024 samples ago (specified in "-hop 1024".)
The [pd delay] window delays the signal itself 1024 samples so it will
be as tightly synchronized with the analysis data as possible. (If
you're doing this on a real-time input \, you might drop the delay
and settle for less perfect synchronization.), f 74;
#X text 175 521 About [sigmund~] \, suffice it to say that we're asking
for frequencies up to 1Khz and the "picth" argument specifies a pitch
output in MIDI. We strip out negative values (when [sigmund~] fails
to find a pitch it outputs "-1500" but we'd rather stick with the most
recent good one). This is converted from MIDI to Hertz \, and multiplied
by 1/2 to control the modulation oscillator. (You can also try large-ish
integers which leave the pitch intact but introduce funny formants.)
, f 74;
#X text 529 642 updated for Pd version 0.52;
#X text 180 276 on/off for original;
#X obj 114 313 *~;
#X obj 132 284 tgl 17 0 empty empty empty 17 7 0 10 #dfdfdf #000000
#000000 0 1;
#X obj 52 313 *~;
#X obj 70 284 tgl 17 0 empty empty empty 17 7 0 10 #dfdfdf #000000
#000000 0 1;
#X text 180 290 and processed sounds;
#X text 155 284 <--;
#X connect 0 0 25 0;
#X connect 1 0 4 0;
#X connect 1 0 4 1;
#X connect 2 0 5 0;
#X connect 6 0 8 1;
#X connect 7 1 9 0;
#X connect 8 0 14 0;
#X connect 9 0 10 0;
#X connect 10 0 6 0;
#X connect 11 0 12 0;
#X connect 12 0 10 1;
#X connect 13 0 12 0;
#X connect 14 0 32 0;
#X connect 15 0 11 0;
#X connect 16 0 19 0;
#X connect 16 0 26 0;
#X connect 18 0 5 0;
#X connect 19 0 8 0;
#X connect 19 0 34 0;
#X connect 25 0 3 0;
#X connect 26 0 7 0;
#X connect 32 0 1 0;
#X connect 33 0 32 1;
#X connect 34 0 1 0;
#X connect 35 0 34 1;
