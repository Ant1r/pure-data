#N canvas 429 79 782 576 12;
#X declare -stdpath ./;
#X obj 266 179 line~;
#X obj 266 155 pack 0 50;
#X floatatom 220 54 4 0 100 0 - - - 0;
#X obj 142 116 *~;
#X obj 220 80 / 10;
#X obj 220 104 moses 0;
#X msg 220 128 0;
#X text 258 54 bandwidth;
#X obj 124 149 *~;
#X obj 88 102 sig~ 1;
#X obj 88 203 /~;
#X obj 106 177 +~;
#X text 157 149 X^2;
#X text 136 180 1+X^2;
#X text 123 205 1/(1+X^2);
#X text 34 11 ANOTHER PULSE WIDTH MOD ALGORITHM;
#N canvas 0 0 450 300 (subpatch) 0;
#X array F04-signal 882 float 0;
#X coords 0 1.02 882 -1.02 200 130 1;
#X restore 536 320 graph;
#N canvas 0 0 450 300 (subpatch) 0;
#X array F04-spectrum 259 float 0;
#X coords 0 1.01 258 -0.008 256 200 1;
#X restore 479 37 graph;
#X text 555 457 ---- 0.02 seconds ----;
#X text 506 236 2;
#X text 537 236 4;
#X text 476 236 0;
#X text 569 236 6;
#X text 602 236 8;
#X text 630 236 10;
#X text 662 236 12;
#X text 694 236 14;
#X obj 88 293 output~;
#N canvas 745 198 546 520 fft 0;
#X text 60 23 This subpatch computes the spectrum of the incoming signal with a (rectangular windowed) FFT. FFTs aren't properly introduced until much later.;
#X obj 389 294 samplerate~;
#X obj 389 317 / 512;
#X obj 389 373 s freq/2;
#X obj 364 143 block~ 4096;
#X text 360 115 Window size;
#X floatatom 389 345 9 0 0 0 - - - 0;
#X obj 43 105 inlet~;
#X obj 142 264 inlet;
#X obj 63 136 rfft~;
#X obj 63 169 *~;
#X obj 95 169 *~;
#X obj 63 199 sqrt~;
#X obj 63 225 biquad~ 0 0 0 0 1;
#X text 127 137 Fourier series;
#X text 132 190 magnitude;
#X text 130 175 calculate;
#X text 105 104 signal to analyze;
#X text 194 216 delay two samples;
#X text 192 234 for better graphing;
#X obj 178 328 metro 500;
#X obj 178 292 inlet;
#X text 231 290 toggle to graph repeatedly, f 15;
#X text 185 264 bang to graph once;
#X obj 63 249 /~ 4096;
#X obj 142 360 b;
#X obj 143 396 tabwrite~ F04-spectrum;
#X obj 43 422 tabwrite~ F04-signal;
#X obj 389 269 loadbang;
#X connect 1 0 2 0;
#X connect 2 0 6 0;
#X connect 6 0 3 0;
#X connect 7 0 9 0;
#X connect 7 0 27 0;
#X connect 8 0 25 0;
#X connect 9 0 10 0;
#X connect 9 0 10 1;
#X connect 9 1 11 0;
#X connect 9 1 11 1;
#X connect 10 0 12 0;
#X connect 11 0 12 0;
#X connect 12 0 13 0;
#X connect 13 0 24 0;
#X connect 20 0 25 0;
#X connect 21 0 20 0;
#X connect 24 0 26 0;
#X connect 25 0 26 0;
#X connect 25 0 27 0;
#X connect 28 0 1 0;
#X restore 145 257 pd fft;
#X obj 164 232 bng 19 250 50 0 empty empty empty 0 -6 0 8 #dfdfdf #000000 #000000;
#X obj 205 257 tgl 19 0 empty empty empty 0 -6 0 8 #dfdfdf #000000 #000000 0 1;
#X obj 142 89 osc~;
#X text 20 386 Here we use waveshaping to make another form of pulse train. This one has a neat spectrum: the partials drop off exponentially (with the "bandwidth" controlling the rate of dropoff.) In later patches we'll use a wavetable to do the waveshaping but for simplicity \, it's done algebraically here. The oscillator runs at half the fundamental frequency. The symmetry of the waveshaping doubles the frequency of the output., f 66;
#X text 741 221 0;
#X text 738 34 1;
#X obj 142 64 r freq/2;
#X obj 230 317 declare -stdpath ./;
#X text 186 232 <-- graph once;
#X text 226 256 <-- repeatedly;
#X obj 88 257 hip~ 5;
#X text 503 264 ------ partial number ------;
#X text 20 495 This is the form of pulse train used in the original Phase Aligned Formant (PAF) algorithm \, which was protected by patents belonging to IRCAM from 1993 to 2011, f 66;
#X connect 0 0 3 1;
#X connect 1 0 0 0;
#X connect 2 0 4 0;
#X connect 3 0 8 0;
#X connect 3 0 8 1;
#X connect 4 0 5 0;
#X connect 5 0 6 0;
#X connect 5 1 1 0;
#X connect 6 0 1 0;
#X connect 8 0 11 1;
#X connect 9 0 10 0;
#X connect 9 0 11 0;
#X connect 10 0 39 0;
#X connect 10 0 28 0;
#X connect 11 0 10 1;
#X connect 29 0 28 1;
#X connect 30 0 28 2;
#X connect 31 0 3 0;
#X connect 35 0 31 0;
#X connect 39 0 27 0;
