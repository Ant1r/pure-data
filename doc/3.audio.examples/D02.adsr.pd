#N canvas 616 48 533 728 12;
#X declare -stdpath ./;
#N canvas 0 0 450 300 (subpatch) 0;
#X array adsr-output 44100 float 0;
#X coords 0 1.02 44100 -0.02 200 130 1 0 0;
#X restore 258 429 graph;
#X text 278 565 ------ 1 second ------;
#X obj 63 199 r trigger;
#X obj 90 334 tabwrite~ adsr-output;
#X obj 104 306 r graphit;
#X msg 283 243 \; pd dsp 1 \; trigger 1 \; graphit bang;
#X msg 283 324 \; pd dsp 1 \; trigger 0 \; graphit bang;
#X msg 297 194 \; trigger 0;
#X text 463 424 1;
#X text 151 19 ENVELOPE GENERATOR ABSTRACTION;
#X obj 45 147 osc~ 440;
#X obj 45 393 *~;
#X obj 45 428 output~;
#X obj 45 526 declare -stdpath ./;
#X obj 283 125 bng 19 250 50 0 empty empty empty 0 -6 0 8 #dfdfdf #000000 #000000;
#X text 306 124 <-- attack and delayed release, f 15;
#X text 55 57 This patch introduces a simple [adsr] abstraction we'll use frequently. You can click on the [adsr] object to see what's inside.;
#X text 56 606 The active ingredient of the ADSR envelope generator is a single [line~] which gets passed messages to make the attack and release behavior. You can retrigger the ADSR envelope generator all you wish without having to wait for attacks or releases to finish;
#X text 386 348 <-- release only;
#X text 382 262 <-- attack only;
#X obj 63 228 tgl 21 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X obj 297 169 del 750;
#X obj 63 261 adsr 1 100 200 50 250;
#X text 461 549 0;
#X connect 2 0 20 0;
#X connect 4 0 3 0;
#X connect 10 0 11 0;
#X connect 11 0 12 0;
#X connect 14 0 5 0;
#X connect 14 0 21 0;
#X connect 20 0 22 0;
#X connect 21 0 7 0;
#X connect 22 0 3 0;
#X connect 22 0 11 1;
