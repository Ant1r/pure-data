#N canvas 522 23 591 646 12;
#X floatatom 334 396 5 0 0 0 - - - 0;
#X obj 46 235 sig~ 50;
#X obj 334 366 snapshot~;
#X obj 334 317 metro 200;
#X obj 46 342 sig~ 25;
#X obj 166 609 tabsend~;
#X obj 98 42 s~;
#X obj 129 42 r~;
#X text 11 609 see also:;
#X obj 78 609 throw~;
#X text 162 41 - abbreviation;
#X obj 334 285 loadbang;
#X floatatom 46 209 5 0 0 0 - - - 0;
#X floatatom 426 396 5 0 0 0 - - - 0;
#X obj 426 366 snapshot~;
#X obj 18 14 send~ x;
#X obj 78 14 receive~ x;
#X obj 46 262 send~ \$0-signal;
#X obj 46 370 send~ signal;
#X msg 204 287 set signal;
#X msg 186 252 set \$1-signal;
#X obj 186 223 f \$0;
#X obj 186 198 bng 19 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X floatatom 46 315 5 0 0 0 - - - 0;
#N canvas 597 199 505 182 execution-order 0;
#X obj 114 123 ../3.audio.examples/G05.execution.order;
#X text 46 30 You have to get the [send~] sorted before the [receive~] or else you'll potentially get a one block delay. Although this is inevitable for feedback loops \, it should be mostly desired in other cases. You can use the strategy given in the example below to control this., f 61;
#X restore 345 547 pd execution-order;
#X obj 186 317 receive~ \$0-signal;
#N canvas 697 108 568 447 reference 0;
#X obj 8 53 cnv 5 550 5 empty empty INLET: 8 18 0 13 #202020 #000000 0;
#X obj 8 97 cnv 2 550 2 empty empty OUTLETS: 8 12 0 13 #202020 #000000 0;
#X obj 6 138 cnv 2 550 2 empty empty ARGUMENTS: 8 12 0 13 #202020 #000000 0;
#X obj 8 185 cnv 5 550 5 empty empty empty 8 18 0 13 #202020 #000000 0;
#X obj 8 321 cnv 2 550 2 empty empty OUTLET: 8 12 0 13 #202020 #000000 0;
#X obj 8 366 cnv 2 550 2 empty empty ARGUMENTS: 8 12 0 13 #202020 #000000 0;
#X obj 7 421 cnv 5 550 5 empty empty empty 8 18 0 13 #202020 #000000 0;
#X text 146 107 NONE;
#X obj 28 15 send~ y;
#X obj 24 245 receive~ y;
#X obj 8 281 cnv 5 550 5 empty empty INLET: 8 18 0 13 #202020 #000000 0;
#X text 109 294 set <name> - set receive name.;
#X text 139 67 signal - signal to send to matching receive~ object(s).;
#X text 138 332 signal - outputs signal from a matching send~ object.;
#X text 124 142 1) symbol - send symbol name (default: empty symbol).;
#X text 106 376 1) symbol - receive name symbol (default: empty symbol).;
#X text 113 394 2) float - number of channels (default: 1)., f 55;
#X text 131 162 2) float - number of channels (default: 1)., f 52;
#X text 89 15 - send signal(s) to one or more [receive~] objects.;
#X text 107 244 - receive signal(s) from a [send~] object.;
#X restore 485 42 pd reference;
#X obj 4 74 cnv 1 580 1 empty empty empty 8 12 0 13 #000000 #000000 0;
#X text 225 202 \$0 needs to be expanded from objects., f 23;
#X text 376 609 updated for Pd version 0.54;
#X obj 426 333 r~ signal;
#N canvas 712 68 510 509 multi-channel 0;
#X floatatom 65 45 5 0 0 0 - - - 0;
#X floatatom 139 45 5 0 0 0 - - - 0;
#X obj 71 279 snapshot~;
#X floatatom 71 305 8 0 0 0 - - - 0;
#X obj 152 279 snapshot~;
#X obj 174 241 metro 250;
#X obj 174 212 loadbang;
#X floatatom 152 305 8 0 0 0 - - - 0;
#X text 388 426 see also:;
#X obj 435 454 clone;
#X text 151 117 <-- 2nd argument sets number;
#X text 179 135 of channels to '2', f 24;
#X obj 65 117 send~ cat 2;
#X obj 65 75 snake~ in 2;
#X obj 71 213 snake~ out 2;
#X obj 378 454 snake~;
#X obj 71 163 receive~ cat;
#X text 170 159 <-- receive outputs the same number of channels, f 23;
#X text 184 17 This example shows how to set number of channels as the 2nd argument \, so it can take a multichannel signal. Set values on the number boxes to the left., f 39;
#X text 63 338 note: you can use "set" messages to switch a receive~ between multichannel send~s with different numbers of channels \, but this can only be done while DSP is off. When DSP is on the send~ channel counts stays fixed., f 54;
#X msg 330 264 \; pd dsp \$1;
#X obj 330 229 set-dsp-tgl;
#X text 361 233 DSP on/off;
#X connect 0 0 13 0;
#X connect 1 0 13 1;
#X connect 2 0 3 0;
#X connect 4 0 7 0;
#X connect 5 0 4 0;
#X connect 5 0 2 0;
#X connect 6 0 5 0;
#X connect 13 0 12 0;
#X connect 14 0 2 0;
#X connect 14 1 4 0;
#X connect 16 0 14 0;
#X connect 21 0 20 0;
#X restore 344 481 pd multi-channel;
#X text 93 482 see multi channel example here -->;
#X text 37 88 A [send~] object copies its input to a local buffer which all [receive~] objects of the same name read from. They may be in different windows or even different patches. Any number of [receive~] may be associated with one [send~] \, but it is an error to have two [send~] objects of the same name. [receive~] takes "set" messages to switch between different [send~] objects. Multi channel connections is supported., f 72;
#X text 162 13 - one-to-many nonlocal signal(s) connection;
#X text 121 515 Example for feedback loops -->;
#N canvas 651 104 520 539 feedback-loop 0;
#X obj 284 323 *~ 0.1;
#X obj 284 293 r~ \$0-fb;
#X obj 249 369 s~ \$0-fb;
#X obj 220 294 noise~;
#X obj 220 325 +~;
#X obj 68 395 block~ 1;
#X obj 221 411 print~;
#X text 338 325 filter coefficient;
#X text 390 368 see also:;
#X obj 404 397 rpole~;
#X text 42 139 You can change the block size for a patch window with the [block~] object \, the default block size is 64 but common examlpes are a single sample feedback loop (block size of 1 for things like filter design and more) or FFT processing with block sizes that are much larger (like 1024 or 2048)., f 60;
#X text 42 19 You can use [send~]/[receive~] for feedback loops. Feedback loops are also useful in delay lines as shown in some of the examples in the 'G' series of the audio examples. Delays are needed when you have to change the delay size \, but sometimes you want a fixed delay time that is the same size of a block of audio. Since the delay time for [send~]/[receive~] is fixed at one block you can use it as the desired fixed delay time.;
#X text 42 235 For reference \, below we have an implementation of [rpole~] (a real one pole filter)., f 60;
#X text 54 448 Note that feedback loops usually require a single (one-to-one) connection \, in this case you can also use [throw~]/[catch~]. Hence \, the decision to focus on [send~]/[receive~] instead is arbitrary., f 62;
#X msg 58 331 \; pd dsp \$1;
#X obj 58 296 set-dsp-tgl;
#X text 89 300 DSP on/off;
#X connect 0 0 4 1;
#X connect 1 0 0 0;
#X connect 3 0 4 0;
#X connect 4 0 2 0;
#X connect 4 0 6 0;
#X connect 15 0 14 0;
#X restore 345 515 pd feedback-loop;
#X obj 230 609 delread~;
#X obj 295 609 block~;
#X obj 4 594 cnv 1 580 1 empty empty empty 8 12 0 13 #000000 #000000 0;
#X text 421 41 click =>;
#X obj 129 609 send;
#X text 156 545 How to prevent delays -->;
#X msg 443 256 \; pd dsp \$1;
#X obj 443 221 set-dsp-tgl;
#X text 474 225 DSP on/off;
#X text 63 433 Note that [send~] and [receive~] must have matching block sizes., f 64;
#X connect 1 0 17 0;
#X connect 2 0 0 0;
#X connect 3 0 2 0;
#X connect 3 0 14 0;
#X connect 4 0 18 0;
#X connect 11 0 3 0;
#X connect 12 0 1 0;
#X connect 14 0 13 0;
#X connect 19 0 25 0;
#X connect 20 0 25 0;
#X connect 21 0 20 0;
#X connect 22 0 21 0;
#X connect 23 0 4 0;
#X connect 25 0 2 0;
#X connect 30 0 14 0;
#X connect 44 0 43 0;
